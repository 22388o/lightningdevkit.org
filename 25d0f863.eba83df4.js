(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{76:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return c})),t.d(n,"metadata",(function(){return s})),t.d(n,"toc",(function(){return u})),t.d(n,"default",(function(){return d}));var a=t(3),r=t(7),i=(t(0),t(88)),o=t(96),l=t(97),c={id:"using_ldk",title:"Using LDK"},s={unversionedId:"using_ldk",id:"using_ldk",isDocsHomePage:!1,title:"Using LDK",description:"Introduction",source:"@site/docs/using_ldk.md",slug:"/using_ldk",permalink:"/docs/using_ldk",editUrl:"https://github.com/lightningdevkit/lightningdevkit.org/tree/main/docs/using_ldk.md",version:"current",sidebar:"someSidebar",previous:{title:"Building a Node with LDK in Rust",permalink:"/docs/build_node_rust"},next:{title:"Key Management",permalink:"/docs/key_mgmt"}},u=[{value:"Introduction",id:"introduction",children:[]},{value:"Connecting Peers",id:"connecting-peers",children:[]},{value:"Managing Channels",id:"managing-channels",children:[{value:"Opening a Channel",id:"opening-a-channel",children:[]},{value:"Closing a Channel",id:"closing-a-channel",children:[]}]},{value:"Sending Payments",id:"sending-payments",children:[]},{value:"Receiving Payments",id:"receiving-payments",children:[]},{value:"Conclusion",id:"conclusion",children:[]}],p={toc:u};function d(e){var n=e.components,t=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},p,t,{components:n,mdxType:"MDXLayout"}),Object(i.b)("h2",{id:"introduction"},"Introduction"),Object(i.b)("p",null,"In this guide, we'll cover common operations when using LDK after you've set up\nyour lightning node."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#connecting-peers"}),"Connecting Peers")," shows how get on the Lightning Network."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#managing-channels"}),"Managing Channels")," covers the ins and outs of channels\nmanagement."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#sending-payments"}),"Sending Payments")," demonstrates making payments using your\nchannels."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#receiving-payments"}),"Receiving Payments")," walks through how to get paid via\nlightning.")),Object(i.b)("p",null,"Time to roll up your sleeves!"),Object(i.b)("h2",{id:"connecting-peers"},"Connecting Peers"),Object(i.b)("p",null,"First things first, let's join the Lightning Network! Connections to other peers\nare established with ",Object(i.b)("inlineCode",{parentName:"p"},"PeerManager"),". You'll need to know the pubkey and address\nof another node that you want as a peer. Once the connection is established and\nthe handshake is complete, ",Object(i.b)("inlineCode",{parentName:"p"},"PeerManager")," will show the peer's pubkey in its list\nof peers."),Object(i.b)(o.a,{defaultValue:"rust",values:[{label:"Rust",value:"rust"},{label:"Java",value:"java"}],mdxType:"Tabs"},Object(i.b)(l.a,{value:"rust",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-rust"}),'match lightning_net_tokio::connect_outbound(Arc::clone(&peer_manager), pubkey, address).await {\n    Some(connection_closed_future) => {\n        let mut connection_closed_future = Box::pin(connection_closed_future);\n        loop {\n            // Make sure the connection is still established.\n            match futures::poll!(&mut connection_closed_future) {\n                std::task::Poll::Ready(_) => {\n                    panic!("ERROR: Peer disconnected before handshake completed");\n                }\n                std::task::Poll::Pending => {}\n            }\n\n            // Wait for the handshake to complete.\n            match peer_manager.get_peer_node_ids().iter().find(|id| **id == pubkey) {\n                Some(_) => break,\n                None => tokio::time::sleep(std::time::Duration::from_millis(10)).await,\n            }\n        }\n    }\n    None => panic!("ERROR: Failed to connect to peer"),\n}\n'))),Object(i.b)(l.a,{value:"java",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"try {\n    // Connect and wait for the handshake to complete.\n    SocketAddress address = new InetSocketAddress(host, port);\n    nio_peer_handler.connect(pubkey, address);\n\n    // The peer's pubkey will be present in the list of peer ids.\n    final PeerManager peer_manager = channel_manager_constructor.peer_manager;\n    byte[][] peer_node_ids = peer_manager.get_peer_node_ids();\n}\ncatch (java.io.IOException e) {\n    // Handle failure to successfully connect to a peer.\n}\n")))),Object(i.b)("h2",{id:"managing-channels"},"Managing Channels"),Object(i.b)("p",null,"Channels are the basic building blocks of the Lightning Network. With channels,\nyou can transact not only with your immediate peers but with others on the\nnetwork. Let's explore how to open and close channels with LDK."),Object(i.b)("h3",{id:"opening-a-channel"},"Opening a Channel"),Object(i.b)("p",null,"Now that you have a peer, you can open a channel with them using\n",Object(i.b)("inlineCode",{parentName:"p"},"ChannelManager"),". You'll need the peer's pubkey as before along with:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"the amount in sats to use when funding the channel,"),Object(i.b)("li",{parentName:"ul"},"any msats to push to your peer,"),Object(i.b)("li",{parentName:"ul"},"an id which is given back in the ",Object(i.b)("inlineCode",{parentName:"li"},"FundingGenerationReady")," event, and"),Object(i.b)("li",{parentName:"ul"},"an optional ",Object(i.b)("inlineCode",{parentName:"li"},"UserConfig")," for overriding ",Object(i.b)("inlineCode",{parentName:"li"},"ChannelManager")," defaults")),Object(i.b)("p",null,"Channels can be announced to the network or can remain private, which is\ncontrolled via ",Object(i.b)("inlineCode",{parentName:"p"},"UserConfig::announced_channel"),"."),Object(i.b)(o.a,{defaultValue:"rust",values:[{label:"Rust",value:"rust"},{label:"Java",value:"java"}],mdxType:"Tabs"},Object(i.b)(l.a,{value:"rust",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-rust"}),'let amount = 10_000;\nlet push_msat = 1_000;\nlet user_id = 42;\nlet config = UserConfig {\n    channel_options: ChannelConfig { announced_channel: true, ..Default::default() },\n    ..Default::default()\n};\nmatch channel_manager.create_channel(pubkey, amount, push_msat, user_id, Some(config)) {\n    Ok(_) => println!("EVENT: initiated channel with peer {}", pubkey),\n    Err(e) => panic!("ERROR: failed to open channel: {:?}", e),\n}\n'))),Object(i.b)(l.a,{value:"java",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"long amount = 10_000L;\nlong push_msat = 1_000L;\nlong user_id = 42L;\nUserConfig config = UserConfig.with_defaults();\nconfig.get_channel_options().set_announced_channel(true);\n\nResult_NoneAPIErrorZ create_channel_result = channel_manager.create_channel(\n    pubkey, amount, push_msat, user_id, config);\nassert create_channel_result instanceof Result_NoneAPIErrorZ.Result_NoneAPIErrorZ_OK;\n")))),Object(i.b)("p",null,"At this point, an outbound channel has been initiated with your peer and it will\nappear in ",Object(i.b)("inlineCode",{parentName:"p"},"ChannelManager::list_channels"),". However, the channel  is not yet\nfunded. Once your peer accepts the channel, you will be notified with a\n",Object(i.b)("inlineCode",{parentName:"p"},"FundingGenerationReady")," event. It's then your responsibility to construct the\nfunding transaction and pass it to ",Object(i.b)("inlineCode",{parentName:"p"},"ChannelManager"),", which will broadcast it\nonce it receives your channel counterparty's signature."),Object(i.b)(o.a,{defaultValue:"rust",values:[{label:"Rust",value:"rust"},{label:"Java",value:"java"}],mdxType:"Tabs"},Object(i.b)(l.a,{value:"rust",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-rust"}),"// In the event handler passed to BackgroundProcessor::start\nmatch event {\n    Event::FundingGenerationReady {\n        temporary_channel_id,\n        channel_value_satoshis,\n        output_script,\n        user_channel_id,\n    } => {\n        // This is the same channel created earler.\n        assert_eq!(event.user_channel_id, 42);\n\n        // Construct the raw transaction with one output, that is paid the amount of the\n        // channel.\n        let network = bitcoin_bech32::constants::Network::Testnet;\n        let address = WitnessProgram::from_scriptpubkey(&output_script[..], network)\n            .unwrap().to_address;\n        let mut outputs = vec![HashMap::with_capacity(1)];\n        outputs[0].insert(address, channel_value_satoshis as f64 / 100_000_000.0);\n        let raw_tx = bitcoind_client.create_raw_transaction(outputs).await;\n\n        // Have your wallet put the inputs into the transaction such that the output is\n        // satisfied.\n        let funded_tx = bitcoind_client.fund_raw_transaction(raw_tx).await;\n        assert!(funded_tx.changepos == 0 || funded_tx.changepos == 1);\n\n        // Sign the funding transaction and give it to ChannelManager to broadcast.\n        let signed_tx = bitcoind_client.sign_raw_transaction_with_wallet(funded_tx.hex).await;\n        assert_eq!(signed_tx.complete, true);\n        let final_tx: Transaction =\n            encode::deserialize(&hex_utils::to_vec(&signed_tx.hex).unwrap()).unwrap();\n        channel_manager.funding_transaction_generated(&temporary_channel_id, final_tx).unwrap();\n    }\n    // ...\n}\n"))),Object(i.b)(l.a,{value:"java",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"// After the peer responds with an `accept_channel` message, an\n// Event.FundingGenerationReady event will be generated.\n\n// In the `handle_event` method of ChannelManagerPersister implementation\nif (e instanceof Event.FundingGenerationReady) {\n    Event.FundingGenerationReady event = (Event.FundingGenerationReady) e;\n    byte[] funding_scriptpubkey = event.output_script;\n    long output_value = event.channel_value_satoshis;\n\n    // This is the same channel created earler\n    assert event.user_channel_id == 42;\n\n    // The output is always a P2WSH:\n    assert funding_scriptpubkey.length == 34 && funding_scriptpubkey[0] == 0 &&\n        funding_scriptpubkey[1] == 32;\n\n    // Generate the funding transaction for the channel based on the channel amount\n    // The following uses the bitcoinj library to do so, but you can use any\n    // standard Bitcoin library for on-chain logic.\n    NetworkParameters bitcoinj_net =\n        NetworkParameters.fromID(NetworkParameters.ID_MAINNET);\n    Transaction funding_tx = new Transaction(bitcoinj_net);\n    funding_tx.addInput(new TransactionInput(bitcoinj_net, funding, new byte[0]));\n    // Note that all inputs in the funding transaction MUST spend SegWit outputs\n    // (and have witnesses)\n    funding_tx.getInputs().get(0).setWitness(new TransactionWitness(2));\n    funding_tx.getInput(0).getWitness().setPush(0, new byte[]{0x1});\n    funding_tx.addOutput(Coin.SATOSHI.multiply(output_value),\n        new Script(funding_scriptpubkey));\n\n    // Give the funding transaction back to the ChannelManager.\n    Result_NoneAPIErrorZ funding_res = channel_manager.funding_transaction_generated(\n        event.temporary_channel_id, funding_tx.bitcoinSerialize());\n    // funding_transaction_generated should only generate an error if the\n    // transaction didn't meet the required format (or the counterparty already\n    // closed the channel on us):\n    assert funding_res instanceof Result_NoneAPIErrorZ.Result_NoneAPIErrorZ_OK;\n}\n")))),Object(i.b)("p",null,"After ",Object(i.b)("inlineCode",{parentName:"p"},"ChannelManager")," has broadcast the funding transaction, the channel will\nbecome usable once the transaction has enough confirmations and will appear in\n",Object(i.b)("inlineCode",{parentName:"p"},"ChannelManager::list_usable_channels"),". See the guide on\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/blockdata"}),"Blockchain Data")," for details on confirmations."),Object(i.b)("p",null,"With a fully funded channel, you can now make Lightning payments! No more hefty\non-chain fees and long confirmation times when you're transacting on layer 2."),Object(i.b)("h3",{id:"closing-a-channel"},"Closing a Channel"),Object(i.b)("p",null,"While a channel can remain open indefinitely, there may come a time when you\nneed to close it. There are two ways to close a channel: either cooperatively or\nunilaterally. The cooperative case makes for lower fees and immediate access to\nfunds while the unilateral case does not. The latter may be necessary if your\npeer isn't behaving properly or has gone offline."),Object(i.b)(o.a,{defaultValue:"rust",values:[{label:"Rust",value:"rust"},{label:"Java",value:"java"}],mdxType:"Tabs"},Object(i.b)(l.a,{value:"rust",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-rust"}),'let channel_id = channel_manager\n    .list_channels()\n    .iter()\n    .find(|channel| channel.user_id == user_id)\n    .expect("ERROR: Channel not found")\n    .channel_id;\n\n// Example: Cooperative close\nchannel_manager.close_channel(&channel_id).expect("ERROR: Failed to close channel");\n\n// Example: Unilateral close\nchannel_manager.force_close_channel(&channel_id).expect("ERROR: Failed to close channel");\n'))),Object(i.b)(l.a,{value:"java",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"// Example: Cooperative close (assuming 1 open channel)\nbyte[] channel_id = channel_manager.list_channels()[0].get_channel_id();\nResult_NoneAPIErrorZ close_result = channel_manager.close_channel(\n    channel_id);\nassert close_result instanceof Result_NoneAPIErrorZ.Result_NoneAPIErrorZ_OK;\n\n// Example: Unilateral close (assuming 1 open channel)\nbyte[] channel_id = channel_manager.list_channels()[0].get_channel_id();\nResult_NoneAPIErrorZ channel_manager.force_close_channel(channel_id);\n")))),Object(i.b)("p",null,"Now that we know how to manage channels, let's put our new channel to use!"),Object(i.b)("h2",{id:"sending-payments"},"Sending Payments"),Object(i.b)("p",null,"Lightning payments are used to pay invoices, which are typically encoded as a\nstring in accordance with BOLT 11. After parsing the invoice, you'll need to\nfind a route from your node to the recipient and then make the payment using\n",Object(i.b)("inlineCode",{parentName:"p"},"ChannelManager"),"."),Object(i.b)(o.a,{defaultValue:"rust",values:[{label:"Rust",value:"rust"},{label:"Java",value:"java"}],mdxType:"Tabs"},Object(i.b)(l.a,{value:"rust",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-rust"}),'// Parse the invoice.\nlet invoice = Invoice::from_str(encoded_invoice)\n    .expect("ERROR: failed to parse invoice");\n\nlet amt_pico_btc = invoice.amount_pico_btc()\n    .expect("ERROR: invalid invoice: must contain amount to pay");\nlet amt_msat = amt_pico_btc / 10;\nlet payer_pubkey = channel_manager.get_our_node_id();\nlet network_graph = router.network_graph.read().unwrap();\nlet payee_pubkey = invoice.recover_payee_pub_key();\nlet payee_features = invoice.features().cloned();\nlet first_hops = channel_manager.list_usable_channels();\nlet last_hops = invoice.route_hints();\nlet final_cltv = invoice.min_final_cltv_expiry() as u32;\n\n// Find a route and send the payment.\nlet route = router::get_route(\n    &payer_pubkey, &network_graph, &payee_pubkey, payee_features,\n    Some(&first_hops.iter().collect::<Vec<_>>()), &last_hops,\n    amt_msat, final_cltv, logger.clone(),\n).expect("ERROR: failed to find route");\n\nlet payment_hash = PaymentHash(invoice.payment_hash().clone().into_inner());\nlet payment_secret = invoice.payment_secret().cloned();\n\nchannel_manager.send_payment(&route, payment_hash, &payment_secret)\n    .expect("ERROR: failed to send payment");\n'))),Object(i.b)(l.a,{value:"java",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"String invoice_str = // get an invoice from the payee\nResult_InvoiceNoneZ parsed_invoice = Invoice.from_str(invoice_str);\n\nif (parsed_invoice instanceof Result_InvoiceNoneZ.Result_InvoiceNoneZ_OK) {\n    Invoice invoice = ((Result_InvoiceNoneZ.Result_InvoiceNoneZ_OK) parsed_invoice).res;\n    long amt_msat = 0;\n    if (invoice.amount_pico_btc() instanceof Option_u64Z.Some) {\n        amt_msat = ((Option_u64Z.Some)invoice.amount_pico_btc()).some / 10;\n    }\n    if (amt_msat == 0) {\n        // <Handle a zero-value invoice>\n    }\n\n    Route route;\n    try (LockedNetworkGraph netgraph = router.read_locked_graph()) {\n        NetworkGraph graph = netgraph.graph();\n        Result_RouteLightningErrorZ route_res = UtilMethods.get_route(\n            channel_manager.get_our_node_id(),\n            graph, invoice.recover_payee_pub_key(), invoice.features(),\n            channel_manager.list_usable_channels(), invoice.route_hints(),\n            amt_msat, invoice.min_final_cltv_expiry(), logger);\n        assert route_res instanceof Result_RouteLightningErrorZ.Result_RouteLightningErrorZ_OK;\n        route = ((Result_RouteLightningErrorZ.Result_RouteLightningErrorZ_OK) route_res).res;\n    }\n\n    Result_NonePaymentSendFailureZ payment_res = channel_manager.send_payment(\n        route, invoice.payment_hash(), invoice.payment_secret());\n    assert payment_res instanceof Result_NonePaymentSendFailureZ.Result_NonePaymentSendFailureZ_OK;\n}\n")))),Object(i.b)("p",null,"An event is generated once a payment has completed. Successful payments result\nin a ",Object(i.b)("inlineCode",{parentName:"p"},"PaymentSent")," event with the preimage of the payment hash. Be sure to look\nout for a ",Object(i.b)("inlineCode",{parentName:"p"},"PaymentFailed")," event, if the payment fails for some reason, and act\naccordingly."),Object(i.b)(o.a,{defaultValue:"rust",values:[{label:"Rust",value:"rust"},{label:"Java",value:"java"}],mdxType:"Tabs"},Object(i.b)(l.a,{value:"rust",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-rust"}),"// In the event handler passed to BackgroundProcessor::start\nmatch event {\n    Event::PaymentSent { payment_preimage } => {\n        // Handle successful payment\n    }\n    Event::PaymentFailed { payment_hash, rejected_by_dest } => {\n        // Handle failed payment\n    }\n    // ...\n}\n"))),Object(i.b)(l.a,{value:"java",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"// In the `handle_event` method of ChannelManagerPersister implementation\nelse if (e instanceof Event.PaymentSent) {\n    // Handle successful payment\n    Event.PaymentSent event = ((Event.PaymentSent) e);\n}\nelse if (e instanceof Event.PaymentFailed) {\n    // Handle failed payment\n    Event.PaymentFailed event = ((Event.PaymentFailed) e);\n}\n")))),Object(i.b)("h2",{id:"receiving-payments"},"Receiving Payments"),Object(i.b)("p",null,"To receive a payment, you'll need to create an invoice of your own with an\namount and description. ",Object(i.b)("inlineCode",{parentName:"p"},"ChannelManager")," contains the remaining information\nneeded for the invoice. Use the provided utility to generate an invoice and\nregister a pending payment in ",Object(i.b)("inlineCode",{parentName:"p"},"ChannelManager"),"."),Object(i.b)(o.a,{defaultValue:"rust",values:[{label:"Rust",value:"rust"},{label:"Java",value:"java"}],mdxType:"Tabs"},Object(i.b)(l.a,{value:"rust",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-rust"}),'let amt_msat = 10_000;\nlet description = "coffee".to_string();\nlet invoice = match utils::create_invoice_from_channelmanager(\n    &channel_manager,\n    keys_manager,\n    currency,\n    Some(amt_msat),\n    description,\n).expect("ERROR: failed to create invoice");\nlet encoded_invoice = invoice.to_string();\n'))),Object(i.b)(l.a,{value:"java",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),'String description = "coffee";\nlong amt_msat = 10_000L;\nResult_InvoiceSignOrCreationErrorZ invoice = UtilMethods.invoice_from_channelmanager(\n    channel_manager, keys_manager.as_KeysInterface(), LDKCurrency.LDKCurrency_Bitcoin,\n    Option_u64Z.some(amt_msat), description);\nassert invoice instanceof\n    Result_InvoiceSignOrCreationErrorZ.Result_InvoiceSignOrCreationErrorZ_OK;\nInvoice invoice = ((Result_InvoiceSignOrCreationErrorZ.Result_InvoiceSignOrCreationErrorZ_OK) invoice).res;\nString encoded_invoice = invoice.to_str();\n')))),Object(i.b)("p",null,"While it is possible to create an invoice without using the utility,\n",Object(i.b)("inlineCode",{parentName:"p"},"ChannelManager")," will reject any incoming HTLCs for unregistered payments to\nprotect your privacy. In this case, use either ",Object(i.b)("inlineCode",{parentName:"p"},"create_inbound_payment")," or\n",Object(i.b)("inlineCode",{parentName:"p"},"create_inbound_payment_for_hash")," to register a payment with ",Object(i.b)("inlineCode",{parentName:"p"},"ChannelManager"),"\nbefore creating the invoice with the returned payment hash and/or secret."),Object(i.b)("p",null,"As with sending a payment, LDK will generate an event once a payment is\nreceived. It is your responsibility to handle the ",Object(i.b)("inlineCode",{parentName:"p"},"PaymentReceived")," event by\nusing ",Object(i.b)("inlineCode",{parentName:"p"},"ChannelManager")," to release the preimage and claim the funds."),Object(i.b)(o.a,{defaultValue:"rust",values:[{label:"Rust",value:"rust"},{label:"Java",value:"java"}],mdxType:"Tabs"},Object(i.b)(l.a,{value:"rust",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-rust"}),'// In the event handler passed to BackgroundProcessor::start\nmatch event {\n    Event::PaymentReceived { payment_hash, payment_preimage, payment_secret, amt, .. } => {\n        let payment_hash = hex_utils::hex_str(&payment_hash.0);\n        match channel_manager.claim_funds(payment_preimage.unwrap()) {\n            true => println!("EVENT: received payment for {}", payment_hash),\n            false => panic!("ERROR: failed to claim payment for {}", payment_hash),\n        }\n    }\n    // ...\n}\n'))),Object(i.b)(l.a,{value:"java",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"// In the `handle_event` method of ChannelManagerPersister implementation\nelse if (e instanceof Event.PaymentReceived) {\n    // Handle successful payment\n    Event.PaymentReceived event = ((Event.PaymentReceived) e);\n    assert event.payment_preimage insanceof Option_PaymentPreimageZ;\n    byte[] payment_preimage = ((Option_PaymentPreimageZ.Some) event.payment_preimage).some;\n    assert channel_manager.claim_funds(payment_preimage);\n}\n")))),Object(i.b)("h2",{id:"conclusion"},"Conclusion"),Object(i.b)("p",null,"So there you have it! Those are the basics of using LDK. As you can see, LDK\noffers a ton of flexibility for building Lightning-enabled wallets and apps."))}d.isMDXComponent=!0},86:function(e,n,t){"use strict";function a(e){var n,t,r="";if("string"==typeof e||"number"==typeof e)r+=e;else if("object"==typeof e)if(Array.isArray(e))for(n=0;n<e.length;n++)e[n]&&(t=a(e[n]))&&(r&&(r+=" "),r+=t);else for(n in e)e[n]&&(r&&(r+=" "),r+=n);return r}n.a=function(){for(var e,n,t=0,r="";t<arguments.length;)(e=arguments[t++])&&(n=a(e))&&(r&&(r+=" "),r+=n);return r}},88:function(e,n,t){"use strict";t.d(n,"a",(function(){return p})),t.d(n,"b",(function(){return m}));var a=t(0),r=t.n(a);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=r.a.createContext({}),u=function(e){var n=r.a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},p=function(e){var n=u(e.components);return r.a.createElement(s.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.a.createElement(r.a.Fragment,{},n)}},h=r.a.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,o=e.parentName,s=c(e,["components","mdxType","originalType","parentName"]),p=u(t),h=a,m=p["".concat(o,".").concat(h)]||p[h]||d[h]||i;return t?r.a.createElement(m,l(l({ref:n},s),{},{components:t})):r.a.createElement(m,l({ref:n},s))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,o=new Array(i);o[0]=h;var l={};for(var c in n)hasOwnProperty.call(n,c)&&(l[c]=n[c]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var s=2;s<i;s++)o[s]=t[s];return r.a.createElement.apply(null,o)}return r.a.createElement.apply(null,t)}h.displayName="MDXCreateElement"},91:function(e,n,t){"use strict";var a=t(0),r=t(92);n.a=function(){const e=Object(a.useContext)(r.a);if(null==e)throw new Error("`useUserPreferencesContext` is used outside of `Layout` Component.");return e}},92:function(e,n,t){"use strict";var a=t(0);const r=Object(a.createContext)(void 0);n.a=r},96:function(e,n,t){"use strict";var a=t(0),r=t.n(a),i=t(91),o=t(86),l=t(53),c=t.n(l);const s=37,u=39;n.a=function(e){const{lazy:n,block:t,defaultValue:l,values:p,groupId:d,className:h}=e,{tabGroupChoices:m,setTabGroupChoices:b}=Object(i.a)(),[_,g]=Object(a.useState)(l),v=a.Children.toArray(e.children);if(null!=d){const e=m[d];null!=e&&e!==_&&p.some((n=>n.value===e))&&g(e)}const y=e=>{g(e),null!=d&&b(d,e)},f=[];return r.a.createElement("div",null,r.a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:Object(o.a)("tabs",{"tabs--block":t},h)},p.map((({value:e,label:n})=>r.a.createElement("li",{role:"tab",tabIndex:0,"aria-selected":_===e,className:Object(o.a)("tabs__item",c.a.tabItem,{"tabs__item--active":_===e}),key:e,ref:e=>f.push(e),onKeyDown:e=>{((e,n,t)=>{switch(t.keyCode){case u:((e,n)=>{const t=e.indexOf(n)+1;e[t]?e[t].focus():e[0].focus()})(e,n);break;case s:((e,n)=>{const t=e.indexOf(n)-1;e[t]?e[t].focus():e[e.length-1].focus()})(e,n)}})(f,e.target,e)},onFocus:()=>y(e),onClick:()=>{y(e)}},n)))),n?Object(a.cloneElement)(v.filter((e=>e.props.value===_))[0],{className:"margin-vert--md"}):r.a.createElement("div",{className:"margin-vert--md"},v.map(((e,n)=>Object(a.cloneElement)(e,{key:n,hidden:e.props.value!==_})))))}},97:function(e,n,t){"use strict";var a=t(3),r=t(0),i=t.n(r);n.a=function({children:e,hidden:n,className:t}){return i.a.createElement("div",Object(a.a)({role:"tabpanel"},{hidden:n,className:t}),e)}}}]);