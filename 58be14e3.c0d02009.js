(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{100:function(e,n,t){"use strict";var a=t(3),r=t(0),i=t.n(r);n.a=function({children:e,hidden:n,className:t}){return i.a.createElement("div",Object(a.a)({role:"tabpanel"},{hidden:n,className:t}),e)}},78:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return s})),t.d(n,"metadata",(function(){return c})),t.d(n,"toc",(function(){return b})),t.d(n,"default",(function(){return p}));var a=t(3),r=t(7),i=(t(0),t(87)),l=t(99),o=t(100),s={id:"build_node",title:"Building a Node with LDK in Java"},c={unversionedId:"build_node",id:"build_node",isDocsHomePage:!1,title:"Building a Node with LDK in Java",description:"Introduction",source:"@site/docs/build_node_rust.md",slug:"/build_node",permalink:"/docs/build_node",editUrl:"https://github.com/lightningdevkit/lightningdevkit.org/tree/main/docs/build_node_rust.md",version:"current",sidebar:"someSidebar",previous:{title:"Use Cases for LDK",permalink:"/docs/use_cases"},next:{title:"Key Management",permalink:"/docs/key_mgmt"}},b=[{value:"Introduction",id:"introduction",children:[]},{value:"Setup",id:"setup",children:[{value:"1. Initialize the <code>FeeEstimator</code>",id:"1-initialize-the-feeestimator",children:[]},{value:"2. Initialize the <code>Logger</code>",id:"2-initialize-the-logger",children:[]},{value:"3. Initialize the <code>BroadcasterInterface</code>",id:"3-initialize-the-broadcasterinterface",children:[]},{value:"4. Initialize <code>Persist</code>",id:"4-initialize-persist",children:[]},{value:"5. Optional: Initialize <code>chain::Filter</code>",id:"5-optional-initialize-chainfilter",children:[]},{value:"6. Initialize the <code>ChainMonitor</code>",id:"6-initialize-the-chainmonitor",children:[]},{value:"7. Initialize the <code>KeysManager</code>",id:"7-initialize-the-keysmanager",children:[]},{value:"8. Read <code>ChannelMonitor</code> state from disk",id:"8-read-channelmonitor-state-from-disk",children:[]},{value:"9. Initialize the <code>ChannelManager</code>",id:"9-initialize-the-channelmanager",children:[]},{value:"10. Sync <code>ChannelMonitor</code>s and <code>ChannelManager</code> to chain tip",id:"10-sync-channelmonitors-and-channelmanager-to-chain-tip",children:[]},{value:"11. Give <code>ChannelMonitor</code>s to <code>ChainMonitor</code>",id:"11-give-channelmonitors-to-chainmonitor",children:[]},{value:"12. Optional: Initialize the <code>NetGraphMsgHandler</code>",id:"12-optional-initialize-the-netgraphmsghandler",children:[]},{value:"13. Initialize the <code>PeerManager</code>",id:"13-initialize-the-peermanager",children:[]},{value:"14. Initialize networking",id:"14-initialize-networking",children:[]}]},{value:"Running LDK",id:"running-ldk",children:[{value:"15. Keep LDK Up-to-date with Chain Info",id:"15-keep-ldk-up-to-date-with-chain-info",children:[]},{value:"16. Handle LDK Events",id:"16-handle-ldk-events",children:[]},{value:"17. Persist <code>ChannelManager</code>",id:"17-persist-channelmanager",children:[]},{value:"18. Background Processing",id:"18-background-processing",children:[]},{value:"19. Regularly Broadcast Node Announcement",id:"19-regularly-broadcast-node-announcement",children:[]}]},{value:"Using LDK",id:"using-ldk",children:[{value:"Opening a Channel",id:"opening-a-channel",children:[]},{value:"Closing a Channel",id:"closing-a-channel",children:[]},{value:"List Channels",id:"list-channels",children:[]},{value:"WIP: Sending/Receiving Payments",id:"wip-sendingreceiving-payments",children:[]},{value:"Connect to Peers",id:"connect-to-peers",children:[]},{value:"List Peers",id:"list-peers",children:[]}]}],d={toc:b};function p(e){var n=e.components,t=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},d,t,{components:n,mdxType:"MDXLayout"}),Object(i.b)("h2",{id:"introduction"},"Introduction"),Object(i.b)("p",null,"This document covers everything you need to make a node using LDK in Rust."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#setup"}),"Setup")," covers everything you need to do to set up LDK on startup."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#running-ldk"}),"Running LDK")," covers everything you need to do while LDK is running to keep it operational."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"#using-ldk"}),"Using LDK")," covers most lightning operations you'll want to use,\nsuch as opening a channel. Sending and receiving payments are supported but\nnot yet a part of this guide.")),Object(i.b)("p",null,"Note that LDK does not assume that safe shutdown is available, so there is no\nshutdown checklist."),Object(i.b)("h2",{id:"setup"},"Setup"),Object(i.b)("h3",{id:"1-initialize-the-feeestimator"},"1. Initialize the ",Object(i.b)("inlineCode",{parentName:"h3"},"FeeEstimator")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"What it's used for:")," estimating fees for on-chain transactions that LDK wants broadcasted."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Example:")),Object(i.b)(l.a,{defaultValue:"rust",values:[{label:"Rust",value:"rust"},{label:"Java",value:"java"}],mdxType:"Tabs"},Object(i.b)(o.a,{value:"rust",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-rust"}),"// main.rs\n\n// BitcoindClient implements the FeeEstimator trait, so it'll act as our fee\n// estimator.\nlet fee_estimator = bitcoind_client.clone();\n\n// bitcoind_client.rs\n\nimpl FeeEstimator for BitcoindClient {\n    fn get_est_sat_per_1000_weight(\n        &self, confirmation_target: ConfirmationTarget,\n    ) -> u32 {\n        match confirmation_target {\n            ConfirmationTarget::Background => // fetch background feerate,\n            ConfirmationTarget::Normal => // fetch normal feerate\n            ConfirmationTarget::HighPriority => // fetch high prio feerate\n        }\n    }\n}\n"))),Object(i.b)(o.a,{value:"java",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"// `FeeEstimatorInterface` is a functional interface, so we can implement it\n// with a lambda.\nfinal fee_estimator = FeeEstimator.new_impl((confirmation_target -> \n        // <insert code to retrieve a fee based based on `confirmation_target`>\n    ));\n")))),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Implementation notes:")," "),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"Fees must be returned in: satoshis per 1000 weight units"),Object(i.b)("li",{parentName:"ol"},"Fees must be no smaller than 253 (equivalent to 1 satoshi/vbyte, rounded up)"),Object(i.b)("li",{parentName:"ol"},"To reduce network traffic, you may want to cache fee results rather than\nretrieving fresh ones every time")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Dependencies:")," ",Object(i.b)("em",{parentName:"p"},"none")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"References:")," ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://docs.rs/lightning/*/lightning/chain/chaininterface/trait.FeeEstimator.html"}),"Rust docs"),", ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/lightningdevkit/ldk-garbagecollected/blob/main/src/main/java/org/ldk/structs/FeeEstimator.java"}),"Java bindings")),Object(i.b)("h3",{id:"2-initialize-the-logger"},"2. Initialize the ",Object(i.b)("inlineCode",{parentName:"h3"},"Logger")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"What it's used for:")," LDK logging"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Example:")),Object(i.b)(l.a,{defaultValue:"rust",values:[{label:"Rust",value:"rust"},{label:"Java",value:"java"}],mdxType:"Tabs"},Object(i.b)(o.a,{value:"rust",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-rust"}),"// main.rs\n\nlet logger = Arc::new(FilesystemLogger::new(ldk_data_dir.clone()));\n\n// disk.rs\nimpl Logger for FilesystemLogger {\n    fn log(&self, record: &Record) {\n        // write log to disk\n    }\n}\n"))),Object(i.b)(o.a,{value:"java",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"/* EXAMPLE THAT PRINTS LOGS TO CONSOLE */\n\n// `LoggerInterface` is a functional interface, so we can implement it with a\n// lambda.\nfinal logger = Logger.new_impl((String arg) -> System.out.println(arg));\n")))),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Implementation notes:")," You'll most likely want to write the logs to a file for debugging purposes."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Dependencies:")," ",Object(i.b)("em",{parentName:"p"},"none")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"References:")," ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://docs.rs/lightning/*/lightning/util/logger/trait.Logger.html"}),"Rust docs"),", ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/lightningdevkit/ldk-garbagecollected/blob/main/src/main/java/org/ldk/structs/Logger.java"}),"Java bindings")),Object(i.b)("h3",{id:"3-initialize-the-broadcasterinterface"},"3. Initialize the ",Object(i.b)("inlineCode",{parentName:"h3"},"BroadcasterInterface")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"What it's used for:")," broadcasting various lightning transactions "),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Example:")),Object(i.b)(l.a,{defaultValue:"rust",values:[{label:"Rust",value:"rust"},{label:"Java",value:"java"}],mdxType:"Tabs"},Object(i.b)(o.a,{value:"rust",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-rust"}),'/* EXAMPLE BROADCASTER USING BITCOIND */\n\n// main.rs\n\nlet broadcaster = bitcoind_client.clone();\n\n// bitcoind_client.rs\n\nimpl BroadcasterInterface for BitcoindClient {\n    fn broadcast_transaction(&self, tx: &Transaction) {\n        let tx_serialized = serde_json::json!(encode::serialize_hex(tx));\n        tokio::spawn(async move {\n            self.rpc.call_method::<RawTx>(\n                "sendrawtransaction",\n                &vec![tx_serialized],\n            ).await.unwrap();\n        });\n    }\n}\n'))),Object(i.b)(o.a,{value:"java",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"// Note that the `tx` argument is a []byte type. \nfinal tx_broadcaster = BroadcasterInterface.new_impl(tx -> {\n    // <insert code to actually broadcast the given transaction here>\n});\n")))),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Dependencies:")," ",Object(i.b)("em",{parentName:"p"},"none")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"References:")," ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://docs.rs/lightning/*/lightning/chain/chaininterface/trait.BroadcasterInterface.html"}),"Rust docs"),", ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/lightningdevkit/ldk-garbagecollected/blob/main/src/main/java/org/ldk/structs/BroadcasterInterface.java"}),"Java bindings")),Object(i.b)("h3",{id:"4-initialize-persist"},"4. Initialize ",Object(i.b)("inlineCode",{parentName:"h3"},"Persist")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"What it's used for:")," persisting crucial channel data in a timely manner"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Example:")),Object(i.b)(l.a,{defaultValue:"rust",values:[{label:"Rust",value:"rust"},{label:"Java",value:"java"}],mdxType:"Tabs"},Object(i.b)(o.a,{value:"rust",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-rust"}),"// main.rs\nuse lightning_persister::FilesystemPersister; // import LDK sample persist module\n\nlet persister = Arc::new(FilesystemPersister::new(ldk_data_dir_path));\n"))),Object(i.b)(o.a,{value:"java",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"Persist persister = Persist.new_impl(new Persist.PersistInterface() {\n  @Override\n  public Result_NoneChannelMonitorUpdateErrZ persist_new_channel(OutPoint id, \n    ChannelMonitor data) {\n      byte[] channel_monitor_bytes = data.write();\n      // <insert code to write these bytes to disk, keyed by `id`>\n  }\n\n  @Override\n  public Result_NoneChannelMonitorUpdateErrZ update_persisted_channel(\n    OutPoint id, ChannelMonitorUpdate update, ChannelMonitor data) {\n      byte[] channel_monitor_bytes = data.write();\n      // <insert code to update the `ChannelMonitor`'s file on disk with these\n      // new bytes, keyed by `id`>\n  }\n});\n")))),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Implementation notes:")," ",Object(i.b)("inlineCode",{parentName:"p"},"ChannelMonitor"),"s are objects which are capable of responding to on-chain\nevents for a given channel. Thus, you will have one ",Object(i.b)("inlineCode",{parentName:"p"},"ChannelMonitor")," per channel, identified by the\nfunding output ",Object(i.b)("inlineCode",{parentName:"p"},"id"),", above. They are persisted in real-time and the ",Object(i.b)("inlineCode",{parentName:"p"},"Persist")," methods will block\nprogress on sending or receiving payments until they return."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Dependencies:")," ",Object(i.b)("em",{parentName:"p"},"none")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"References:")," ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://docs.rs/lightning/*/lightning/chain/channelmonitor/trait.Persist.html"}),"Rust docs"),", ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/lightningdevkit/ldk-garbagecollected/blob/main/src/main/java/org/ldk/structs/Persist.java"}),"Java bindings"),", ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/rust-bitcoin/rust-lightning/tree/main/lightning-persister"}),"Rust sample persister module")),Object(i.b)("h3",{id:"5-optional-initialize-chainfilter"},"5. Optional: Initialize ",Object(i.b)("inlineCode",{parentName:"h3"},"chain::Filter")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"You must follow this step if:")," you are ",Object(i.b)("em",{parentName:"p"},"not")," providing full blocks to LDK,\ni.e. if you're using BIP 157/158 or Electrum as your chain backend"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"What it's used for:")," if you are not providing full blocks, LDK uses this\nobject to tell you what transactions and outputs to watch for on-chain. You'll\ninform LDK about these transactions/outputs in ","[TODO link later step]","."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Example:")),Object(i.b)(l.a,{defaultValue:"rust",values:[{label:"Rust",value:"rust"},{label:"Java",value:"java"}],mdxType:"Tabs"},Object(i.b)(o.a,{value:"rust",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-rust"}),"// main.rs\n\nlet filter = YourChainBackend::new(..);\n\n    \n// chain_backend.rs\n\nimpl Filter for YourChainBackend {\n    fn register_tx(&self, txid: &Txid, script_pubkey: &Script) {\n        // <insert code for you to watch for this transaction on-chain>\n    }\n    \n    fn register_output(&self, output: WatchedOutput) -> \n        Option<(usize, Transaction)> {\n\n        // <insert code for you to watch for any transactions that spend this\n        // output on-chain>\n    }\n}\n"))),Object(i.b)(o.a,{value:"java",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"Filter tx_filter = Filter.new_impl(new Filter.FilterInterface() {\n    @Override\n    public void register_tx(byte[] txid, byte[] script_pubkey) {\n        // <insert code for you to watch for this transaction on-chain>\n    }\n    \n    @Override\n    void register_output(OutPoint outpoint, byte[] script_pubkey) {\n        // <insert code for you to watch for any transactions that spend this\n        // output on-chain>\n    }\n});\n")))),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Dependencies:")," ",Object(i.b)("em",{parentName:"p"},"none")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"References:")," ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://docs.rs/lightning/*/lightning/chain/trait.Filter.html"}),"Rust docs"),", ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/lightningdevkit/ldk-garbagecollected/blob/main/src/main/java/org/ldk/structs/Filter.java"}),"Java bindings")),Object(i.b)("h3",{id:"6-initialize-the-chainmonitor"},"6. Initialize the ",Object(i.b)("inlineCode",{parentName:"h3"},"ChainMonitor")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"What it's used for:")," tracking one or more ",Object(i.b)("inlineCode",{parentName:"p"},"ChannelMonitor"),"s and using them to monitor the chain for lighting transactions that are relevant to our node, and broadcasting transactions if need be"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Example:")),Object(i.b)(l.a,{defaultValue:"rust",values:[{label:"Rust",value:"rust"},{label:"Java",value:"java"}],mdxType:"Tabs"},Object(i.b)(o.a,{value:"rust",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-rust"}),"// main.rs\n\nlet filter: Option<Filter> = // leave this as None or insert the Filter trait\n                             // object, depending on what you did for Step 5\n\nlet chain_monitor: Arc<ChainMonitor> =\n    Arc::new(chainmonitor::ChainMonitor::new(\n        filter,\n        broadcaster.clone(),\n        logger.clone(),\n        fee_estimator.clone(),\n        persister.clone(),\n    ));\n"))),Object(i.b)(o.a,{value:"java",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"final filter = // leave this as `null` or insert the Filter object, depending on\n               // what you did for Step 5\nfinal chain_monitor = ChainMonitor.constructor_new(filter, tx_broadcaster, logger,\n    fee_estimator, persister);\n")))),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Dependencies:")," ",Object(i.b)("inlineCode",{parentName:"p"},"FeeEstimator"),", ",Object(i.b)("inlineCode",{parentName:"p"},"Logger"),", ",Object(i.b)("inlineCode",{parentName:"p"},"BroadcasterInterface"),", ",Object(i.b)("inlineCode",{parentName:"p"},"Persist")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Optional dependency:")," ",Object(i.b)("inlineCode",{parentName:"p"},"Filter")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"References:")," ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://docs.rs/lightning/*/lightning/chain/chainmonitor/struct.ChainMonitor.html"}),"Rust docs"),", ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/lightningdevkit/ldk-garbagecollected/blob/main/src/main/java/org/ldk/structs/ChainMonitor.java"}),"Java bindings")),Object(i.b)("h3",{id:"7-initialize-the-keysmanager"},"7. Initialize the ",Object(i.b)("inlineCode",{parentName:"h3"},"KeysManager")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"What it's used for:")," providing keys for signing lightning transactions"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Example:")),Object(i.b)(l.a,{defaultValue:"rust",values:[{label:"Rust",value:"rust"},{label:"Java",value:"java"}],mdxType:"Tabs"},Object(i.b)(o.a,{value:"rust",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-rust"}),'// main.rs\n\nlet keys_seed_path = format!("{}/keys_seed", ldk_data_dir.clone());\n\n// If we\'re restarting and already have a key seed, read it from disk. Else,\n// create a new one.\nlet keys_seed = if let Ok(seed) = fs::read(keys_seed_path.clone()) {\n    assert_eq!(seed.len(), 32);\n    let mut key = [0; 32];\n    key.copy_from_slice(&seed);\n    key\n} else {\n    let mut key = [0; 32];\n    thread_rng().fill_bytes(&mut key);\n    match File::create(keys_seed_path.clone()) {\n        Ok(mut f) => {\n            f.write_all(&key)\n                .expect("Failed to write node keys seed to disk");\n            f.sync_all().expect("Failed to sync node keys seed to disk");\n        }\n        Err(e) => {\n            println!(\n                "ERROR: Unable to create keys seed file {}: {}",\n                keys_seed_path, e\n            );\n            return;\n        }\n    }\n    key\n};\nlet cur = SystemTime::now().duration_since(SystemTime::UNIX_EPOCH).unwrap();\nlet keys_manager = Arc::new(KeysManager::new(\n    &keys_seed,\n    cur.as_secs(),\n    cur.subsec_nanos(),\n));\n'))),Object(i.b)(o.a,{value:"java",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"byte[] key_seed = new byte[32];\n// <insert code to fill key_seed with random bytes OR if restarting, reload the\n// seed from disk>\nKeysManager keys_manager = KeysManager.constructor_new(key_seed,\n    System.currentTimeMillis() / 1000,\n    (int) (System.currentTimeMillis() * 1000));\n")))),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Implementation notes:")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"See the Key Management guide for more information."),Object(i.b)("li",{parentName:"ul"},"Note that you must write the ",Object(i.b)("inlineCode",{parentName:"li"},"key_seed")," you give to the ",Object(i.b)("inlineCode",{parentName:"li"},"KeysManager")," on\nstartup to disk, and keep using it to initialize the ",Object(i.b)("inlineCode",{parentName:"li"},"KeysManager")," every time\nyou restart. This ",Object(i.b)("inlineCode",{parentName:"li"},"key_seed")," is used to derive your node's secret key (which\ncorresponds to its node pubkey) and all other secret key material."),Object(i.b)("li",{parentName:"ul"},"The current time is part of the ",Object(i.b)("inlineCode",{parentName:"li"},"KeysManager"),"'s parameters because it is used to derive\nrandom numbers from the seed where required, to ensure all random\ngeneration is unique across restarts.")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Dependencies:")," random bytes"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"References:")," ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://docs.rs/lightning/*/lightning/chain/keysinterface/struct.KeysManager.html"}),"Rust docs"),", ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/lightningdevkit/ldk-garbagecollected/blob/main/src/main/java/org/ldk/structs/KeysManager.java"}),"Java bindings")),Object(i.b)("h3",{id:"8-read-channelmonitor-state-from-disk"},"8. Read ",Object(i.b)("inlineCode",{parentName:"h3"},"ChannelMonitor")," state from disk"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"What it's used for:")," if LDK is restarting and has at least 1 channel, its channel state will need to be read from disk and fed to the ",Object(i.b)("inlineCode",{parentName:"p"},"ChannelManager")," on the next step."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Example:")," reading ",Object(i.b)("inlineCode",{parentName:"p"},"ChannelMonitor"),"s from disk, where each ",Object(i.b)("inlineCode",{parentName:"p"},"ChannelMonitor"),"'s file is named after its funding outpoint:"),Object(i.b)(l.a,{defaultValue:"rust",values:[{label:"Rust",value:"rust"},{label:"Java",value:"java"}],mdxType:"Tabs"},Object(i.b)(o.a,{value:"rust",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-rust"}),"// main.rs\n\n// Use LDK's sample persister module provided method\nlet mut channelmonitors =\n    persister.read_channelmonitors(keys_manager.clone()).unwrap();\n"))),Object(i.b)(o.a,{value:"java",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"// Initialize the array where we'll store the `ChannelMonitor`s read from disk.\nfinal ArrayList channel_monitor_list = new ArrayList<>();\n\n// For each monitor stored on disk, deserialize it and place it in \n// `channel_monitors`.\nfor (... : monitor_files) {\n    byte[] channel_monitor_bytes = // read the bytes from disk the same way you\n                                   // wrote them in Step 4\n    channel_monitor_list.add(channel_monitor_bytes);\n}\n\n// Convert the ArrayList into an array so we can pass it to\n// `ChannelManagerConstructor` in the next step.\nfinal byte[][] channel_monitors = channel_monitor_list.toArray(new byte[1][]);\n")))),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Dependencies:")," in Rust: ",Object(i.b)("inlineCode",{parentName:"p"},"KeysManager")),Object(i.b)("h3",{id:"9-initialize-the-channelmanager"},"9. Initialize the ",Object(i.b)("inlineCode",{parentName:"h3"},"ChannelManager")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"What it's used for:")," managing channel state"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Example:")),Object(i.b)(l.a,{defaultValue:"rust",values:[{label:"Rust",value:"rust"},{label:"Java",value:"java"}],mdxType:"Tabs"},Object(i.b)(o.a,{value:"rust",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-rust"}),'// main.rs\n\nlet user_config = UserConfig::default();\nlet (channel_manager_blockhash, mut channel_manager) = {\n    if let Ok(mut f) =\n        fs::File::open(format!("{}/manager", ldk_data_dir.clone()))\n    {\n        let mut channel_monitor_mut_references = Vec::new();\n        for (_, channel_monitor) in channelmonitors.iter_mut() {\n            channel_monitor_mut_references.push(channel_monitor);\n        }\n        let read_args = ChannelManagerReadArgs::new(\n            keys_manager.clone(),\n            fee_estimator.clone(),\n            chain_monitor.clone(),\n            broadcaster.clone(),\n            logger.clone(),\n            user_config,\n            channel_monitor_mut_references,\n        );\n        <(BlockHash, ChannelManager)>::read(&mut f, read_args).unwrap()\n    } else {\n        // We\'re starting a fresh node.\n        let getinfo_resp = bitcoind_client.get_blockchain_info().await;\n\n        let chain_params = ChainParameters {\n            network: args.network,\n            best_block: BestBlock::new(\n                getinfo_resp.latest_blockhash,\n                getinfo_resp.latest_height as u32,\n            ),\n        };\n        let fresh_channel_manager = ChannelManager::new(\n            fee_estimator.clone(),\n            chain_monitor.clone(),\n            broadcaster.clone(),\n            logger.clone(),\n            keys_manager.clone(),\n            user_config,\n            chain_params,\n        );\n        (getinfo_resp.latest_blockhash, fresh_channel_manager)\n    }\n};\n'))),Object(i.b)(o.a,{value:"java",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"/* FRESH CHANNELMANAGER */\n\nint block_height = // <insert current chain tip height>;\nfinal channel_manager = ChannelManager.constructor_new(\n    LDKNetwork.LDKNetwork_Bitcoin, fee_estimator, chain_monitor.as_Watch(), \n    tx_broadcaster, logger, keys_manager.as_KeysInterface(), \n    UserConfig.constructor_default(), block_height);\n    \n/* RESTARTING CHANNELMANAGER */\n\nbyte[] serialized_channel_manager = // <insert bytes written in Step TODO\nChannelManagerConstructor channel_manager_constructor = new ChannelManagerConstructor(\n  serialized_channel_manager, channel_monitors, keys_manager.as_KeysInterface(),\n  fee_estimator, chain_monitor.as_Watch(), tx_broadcaster, logger);\n\nfinal channel_manager = channel_manager_constructor.channel_manager;\n    \n")))),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Implementation notes:")," No methods should be called on ",Object(i.b)("inlineCode",{parentName:"p"},"ChannelManager")," until\nafter step 10 and step 11."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Dependencies:")," ",Object(i.b)("inlineCode",{parentName:"p"},"KeysManager"),", ",Object(i.b)("inlineCode",{parentName:"p"},"FeeEstimator"),", ",Object(i.b)("inlineCode",{parentName:"p"},"ChainMonitor"),", ",Object(i.b)("inlineCode",{parentName:"p"},"BroadcasterInterface"),", ",Object(i.b)("inlineCode",{parentName:"p"},"Logger"),", channel configuration info, and the set of ",Object(i.b)("inlineCode",{parentName:"p"},"ChannelMonitor"),"s we read from disk in step 8, if restarting"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"References:")," ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://docs.rs/lightning/*/lightning/ln/channelmanager/struct.ChannelManager.html"}),"Rust ",Object(i.b)("inlineCode",{parentName:"a"},"ChannelManager")," docs"),", ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/lightningdevkit/ldk-garbagecollected/blob/main/src/main/java/org/ldk/structs/ChannelManager.java"}),"Java ",Object(i.b)("inlineCode",{parentName:"a"},"ChannelManager")," bindings")),Object(i.b)("h3",{id:"10-sync-channelmonitors-and-channelmanager-to-chain-tip"},"10. Sync ",Object(i.b)("inlineCode",{parentName:"h3"},"ChannelMonitor"),"s and ",Object(i.b)("inlineCode",{parentName:"h3"},"ChannelManager")," to chain tip"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"What it's used for:")," if you're restarting and have open channels, this step ensures that channel state is up-to-date with the bitcoin blockchain"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Example:")),Object(i.b)(l.a,{defaultValue:"rust",values:[{label:"Rust with Bitcoind Backend",value:"rust"},{label:"Java",value:"java"}],mdxType:"Tabs"},Object(i.b)(o.a,{value:"rust",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-rust"}),"// main.rs\n\n// Import LDK's sample block sync module.\nuse lightning_block_sync::init;\nuse lightning_block_sync::poll;\nuse lightning_block_sync::SpvClient;\nuse lightning_block_sync::UnboundedCache;\n\nlet mut chain_listener_channel_monitors = Vec::new();\nlet mut cache = UnboundedCache::new();\nlet mut chain_tip: Option<poll::ValidatedBlockHeader> = None;\nif restarting_node {\n    let mut chain_listeners = vec![(\n        channel_manager_blockhash,\n        &mut channel_manager as &mut dyn chain::Listen,\n    )];\n\n    for (blockhash, channel_monitor) in channelmonitors.drain(..) {\n        let outpoint = channel_monitor.get_funding_txo().0;\n        chain_listener_channel_monitors.push((\n            blockhash,\n            (\n                channel_monitor,\n                broadcaster.clone(),\n                fee_estimator.clone(),\n                logger.clone(),\n            ),\n            outpoint,\n        ));\n    }\n\n    for monitor_listener_info in chain_listener_channel_monitors.iter_mut()\n    {\n        chain_listeners.push((\n            monitor_listener_info.0,\n            &mut monitor_listener_info.1 as &mut dyn chain::Listen,\n        ));\n    }\n    chain_tip = Some(\n        init::synchronize_listeners(\n            &mut bitcoind_client.deref(),\n            args.network,\n            &mut cache,\n            chain_listeners,\n        )\n        .await\n        .unwrap(),\n    );\n}\n"))),Object(i.b)(o.a,{value:"java",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"// Retrieve transaction IDs to check the chain for un-confirmation.\nbyte[][] relevant_txids_1 = channel_manager.as_Confirm().get_relevant_txids();\nbyte[][] relevant_txids_2 = chain_monitor.as_Confirm().get_relevant_txids();\nbyte[][] relevant_txids = ArrayUtils.addAll(\n    relevant_txids_1, relevant_txids_2\n);\n\nbyte[][] unconfirmed_txids = // <insert code to find out from your chain source\n                             //  if any of relevant_txids have been reorged out\n                             //  of the chain>\n\nfor (byte[] txid : unconfirmed_txids) {\n    channel_manager.transaction_unconfirmed(txid);\n    chain_monitor.transaction_unconfirmed(txid);\n}\n\n// Retrieve transactions and outputs that were registered through the `Filter`\n// interface.\n\n// If any of these txs/outputs were confirmed on-chain, then:\nbyte[] header = // insert block header from the block with confirmed tx/output\nint height = // insert block height of `header`\nLong tx_index = // insert tx index in block\nbyte[] serialized_tx = // insert tx hex as byte array\nTwoTuple<Long, byte[]> tx = new TwoTuple<>(tx_index, serialized_tx);\n\n// Marshall all TwoTuples you built right above into an array\nTwoTuple<Long, byte[]>[] tx_list = new TwoTuple[]{tx, .. };\n\nchannel_manager.transactions_confirmed(header, height, tx_list);\nchain_monitor.transactions_confirmed(header, height, tx_list);\n\nbyte[] best_header = // <insert code to get your best known header>\nint best_height = // <insert code to get your best known block height>\nchannel_manager.update_best_block(best_header, best_height);\nchain_monitor.update_best_block(best_header, best_height);\n")))),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Implementation notes:")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"There are 2 main options for synchronizing to chain on startup:",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"If you are using Rust and connecting full blocks, then it is recommended to use\nLDK's ",Object(i.b)("inlineCode",{parentName:"li"},"lightning_block_sync")," sample module"),Object(i.b)("li",{parentName:"ul"},"If you are connecting full blocks or using BIP 157/158,  // TODO"),Object(i.b)("li",{parentName:"ul"},"Otherwise, you can use LDK's ",Object(i.b)("inlineCode",{parentName:"li"},"Confirm")," interface as such: // TODO"))),Object(i.b)("li",{parentName:"ul"},"More details about LDK's interfaces to provide chain info in step 15")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"References:")," ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://docs.rs/lightning/*/lightning/chain/trait.Confirm.html"}),"Rust docs for ",Object(i.b)("inlineCode",{parentName:"a"},"Confirm")," interface"),", ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://docs.rs/lightning-block-sync/*/lightning_block_sync/"}),"Rust ",Object(i.b)("inlineCode",{parentName:"a"},"lightning_block_sync")," module docs")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Dependencies:")," ",Object(i.b)("inlineCode",{parentName:"p"},"ChannelManager"),", ",Object(i.b)("inlineCode",{parentName:"p"},"ChainMonitor"),", chain source"),Object(i.b)("h3",{id:"11-give-channelmonitors-to-chainmonitor"},"11. Give ",Object(i.b)("inlineCode",{parentName:"h3"},"ChannelMonitor"),"s to ",Object(i.b)("inlineCode",{parentName:"h3"},"ChainMonitor")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"What it's used for:")," ",Object(i.b)("inlineCode",{parentName:"p"},"ChainMonitor")," is responsible for updating the ",Object(i.b)("inlineCode",{parentName:"p"},"ChannelMonitor"),"s during LDK node operation."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Example:")),Object(i.b)(l.a,{defaultValue:"rust",values:[{label:"Rust",value:"rust"},{label:"Java",value:"java"}],mdxType:"Tabs"},Object(i.b)(o.a,{value:"rust",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-rust"}),"// main.rs\n\nfor (funding_outpoint, channel_monitor) in channel_monitors.drain(..) {\n    chain_monitor.watch_channel(funding_outpoint, channel_monitor).unwrap();\n}\n"))),Object(i.b)(o.a,{value:"java",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"// Note that if you use the ChannelManagerConstructor utility,\n// it handles this for you in chain_sync_completed().\nchannel_manager_constructor.chain_sync_completed();\n")))),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Dependencies:")," "),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Java: ",Object(i.b)("inlineCode",{parentName:"li"},"ChannelManagerConstructor")),Object(i.b)("li",{parentName:"ul"},"Not Java: ",Object(i.b)("inlineCode",{parentName:"li"},"ChainMonitor"),", set of ",Object(i.b)("inlineCode",{parentName:"li"},"ChannelMonitor"),"s and their funding outpoints"),Object(i.b)("li",{parentName:"ul"},"Step 10 must be completed prior to this step")),Object(i.b)("h3",{id:"12-optional-initialize-the-netgraphmsghandler"},"12. Optional: Initialize the ",Object(i.b)("inlineCode",{parentName:"h3"},"NetGraphMsgHandler")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"You must follow this step if:")," you need LDK to provide routes for sending payments (i.e. you are ",Object(i.b)("em",{parentName:"p"},"not")," providing your own routes)"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"What it's used for:")," generating routes to send payments over"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Example:")," initializing ",Object(i.b)("inlineCode",{parentName:"p"},"NetGraphMsgHandler")," without providing an ",Object(i.b)("inlineCode",{parentName:"p"},"Access")),Object(i.b)(l.a,{defaultValue:"rust",values:[{label:"Rust",value:"rust"},{label:"Java",value:"java"}],mdxType:"Tabs"},Object(i.b)(o.a,{value:"rust",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-rust"}),"// main.rs\n\nlet genesis = genesis_block(args.network).header.block_hash();\nlet router = Arc::new(NetGraphMsgHandler::new(\n    genesis,\n    None::<Arc<dyn chain::Access + Send + Sync>>,\n    logger.clone(),\n));\n"))),Object(i.b)(o.a,{value:"java",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"final router = NetGraphMsgHandler.constructor_new(new byte[32], null, logger);\n")))),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Implementation notes:")," this struct is not required if you are providing your own routes."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Dependencies:")," ",Object(i.b)("inlineCode",{parentName:"p"},"Logger")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Optional dependency:")," ",Object(i.b)("inlineCode",{parentName:"p"},"Access"),", a source of chain information. Recommended to be able to verify channels before adding them to the internal network graph."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"References:")," ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://docs.rs/lightning/*/lightning/routing/network_graph/struct.NetGraphMsgHandler.html"}),Object(i.b)("inlineCode",{parentName:"a"},"NetGraphMsgHandler")," Rust docs"),", ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/lightningdevkit/ldk-garbagecollected/blob/main/src/main/java/org/ldk/structs/NetGraphMsgHandler.java"}),"Java bindings"),", ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://docs.rs/lightning/*/lightning/chain/trait.Access.html"}),Object(i.b)("inlineCode",{parentName:"a"},"Access")," Rust docs"),", ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/lightningdevkit/ldk-garbagecollected/blob/main/src/main/java/org/ldk/structs/Access.java"}),Object(i.b)("inlineCode",{parentName:"a"},"Access")," Java bindings")),Object(i.b)("h3",{id:"13-initialize-the-peermanager"},"13. Initialize the ",Object(i.b)("inlineCode",{parentName:"h3"},"PeerManager")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"What it's used for:")," managing peer data and connections"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Example:")),Object(i.b)(l.a,{defaultValue:"rust",values:[{label:"Rust",value:"rust"},{label:"Java",value:"java"}],mdxType:"Tabs"},Object(i.b)(o.a,{value:"rust",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-rust"}),"// main.rs\n\nlet mut ephemeral_bytes = [0; 32];\nrand::thread_rng().fill_bytes(&mut ephemeral_bytes);\nlet lightning_msg_handler = MessageHandler {\n    chan_handler: channel_manager.clone(),\n    route_handler: router.clone(),\n};\nlet peer_manager: Arc<PeerManager> = Arc::new(PeerManager::new(\n    lightning_msg_handler,\n    keys_manager.get_node_secret(),\n    &ephemeral_bytes,\n    logger.clone(),\n));\n"))),Object(i.b)(o.a,{value:"java",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"byte[] random_bytes = new byte[32];\n// <insert code to fill in `random_data` with random bytes>\n\nfinal peer_manager = PeerManager.constructor_new(\n    channel_manager.as_ChannelMessageHandler(), router.as_RoutingMessageHandler(),\n    keys_manager.as_KeysInterface().get_node_secret(), random_bytes, logger);\n")))),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Implementation notes:")," if you did not initialize ",Object(i.b)("inlineCode",{parentName:"p"},"NetGraphMsgHandler")," in the previous step, you can initialize your own struct (which can be a dummy struct) that implements ",Object(i.b)("inlineCode",{parentName:"p"},"RoutingMessageHandlerInterface")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Dependencies:")," ",Object(i.b)("inlineCode",{parentName:"p"},"ChannelManager"),", ",Object(i.b)("inlineCode",{parentName:"p"},"RoutingMessageHandlerInterface"),", ",Object(i.b)("inlineCode",{parentName:"p"},"KeysManager"),", random bytes, ",Object(i.b)("inlineCode",{parentName:"p"},"Logger")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"References:")," ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://docs.rs/lightning/*/lightning/ln/peer_handler/struct.PeerManager.html"}),"Rust docs"),", ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/lightningdevkit/ldk-garbagecollected/blob/main/src/main/java/org/ldk/structs/PeerManager.java"}),"Java ",Object(i.b)("inlineCode",{parentName:"a"},"PeerManager")," bindings"),", ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://docs.rs/lightning/*/lightning/ln/msgs/trait.RoutingMessageHandler.html"}),"Rust ",Object(i.b)("inlineCode",{parentName:"a"},"RoutingMessageHandler")," docs"),", ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/lightningdevkit/ldk-garbagecollected/blob/main/src/main/java/org/ldk/structs/RoutingMessageHandler.java"}),"Java ",Object(i.b)("inlineCode",{parentName:"a"},"RoutingMessageHandler")," bindings")),Object(i.b)("h3",{id:"14-initialize-networking"},"14. Initialize networking"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"What it's used for:")," making peer connections, facilitating peer data to and from LDK"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Example:")),Object(i.b)(l.a,{defaultValue:"rust",values:[{label:"Rust",value:"rust"},{label:"Java",value:"java"}],mdxType:"Tabs"},Object(i.b)(o.a,{value:"rust",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-rust"}),'// main.rs\n\nlet peer_manager_connection_handler = peer_manager.clone();\nlet listen_port = args.ldk_peer_listening_port;\ntokio::spawn(async move {\n    let listener = tokio::net::TcpListener::bind(format!("0.0.0.0:{}", listen_port))\n        .await.unwrap()\n    loop {\n        let peer_mgr = peer_manager_connection_handler.clone();\n        let tcp_stream = listener.accept().await.unwrap().0;\n        tokio::spawn(async move {\n            // Use LDK\'s supplied Rust networking battery to facilitate\n            // inbound connections.\n            lightning_net_tokio::setup_inbound(\n                peer_mgr.clone(),\n                tcp_stream.into_std().unwrap(),\n            )\n            .await;\n        });\n    }\n});\n'))),Object(i.b)(o.a,{value:"java",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),'\n// Use LDK\'s supplied Java networking battery, `NioPeerHandler`.\nfinal nio_peer_handler;\ntry { \n    nio_peer_handler = new NioPeerHandler(peer_manager); \n} catch (IOException e) { assert false; }\n\n// Start `NioPeerHandler` listening for connections.\nfinal port = 9735;\nnio_peer_handler.bind_listener(new InetSocketAddress("0.0.0.0", port));\n')))),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Dependencies:")," ",Object(i.b)("inlineCode",{parentName:"p"},"PeerManager")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"References:")," ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://docs.rs/lightning-net-tokio/0.0.14/lightning_net_tokio/"}),"Rust ",Object(i.b)("inlineCode",{parentName:"a"},"lightning-net-tokio")," sample networking module"),", ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/lightningdevkit/ldk-garbagecollected/blob/main/src/main/java/org/ldk/batteries/NioPeerHandler.java"}),"Java ",Object(i.b)("inlineCode",{parentName:"a"},"NioPeerHandler")," sample networking module")),Object(i.b)("h2",{id:"running-ldk"},"Running LDK"),Object(i.b)("p",null,"This section assumes you've already run all the steps in ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#setup"}),"Setup"),"."),Object(i.b)("h3",{id:"15-keep-ldk-up-to-date-with-chain-info"},"15. Keep LDK Up-to-date with Chain Info"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"What it's used for:")," LDK needs to know when blocks are newly connected and disconnected and when relevant transactions are confirmed and/or reorged out."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Example:")),Object(i.b)(l.a,{defaultValue:"rust",values:[{label:"Rust with Bitcoind",value:"rust"},{label:"Java with Electrum",value:"java-electrum"},{label:"Java with Full Blocks or BIP 157/158",value:"java-blocks"}],mdxType:"Tabs"},Object(i.b)(o.a,{value:"rust",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-rust"}),"// main.rs\n\n// If you don't have the chain tip, retrieve it here.\nif chain_tip.is_none() {\n    chain_tip = Some(\n        init::validate_best_block_header(&mut bitcoind_client.deref())\n            .await\n            .unwrap(),\n    );\n}\ntokio::spawn(async move {\n    let mut derefed = bitcoind_client.deref();\n    let chain_poller = poll::ChainPoller::new(&mut derefed, network);\n    let chain_listener = (chain_monitor, channel_manager);\n    let mut spv_client = SpvClient::new(\n        chain_tip.unwrap(),\n        chain_poller,\n        &mut cache,\n        &chain_listener,\n    );\n    loop {\n        // `poll_best_tip` will update ChannelManager and ChainMonitor with the\n        // best chain tip as needed.\n        spv_client.poll_best_tip().await.unwrap();\n        tokio::time::sleep(Duration::from_secs(1)).await;\n    }\n});\n"))),Object(i.b)(o.a,{value:"java-electrum",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"/* UNCONFIRMED TRANSACTIONS */\n\n// Retrieve transaction IDs to check the chain for un-confirmation.\nbyte[][] relevant_txids_1 = channel_manager.as_Confirm().get_relevant_txids();\nbyte[][] relevant_txids_2 = chain_monitor.as_Confirm().get_relevant_txids();\nbyte[][] relevant_txids = ArrayUtils.addAll(\n    relevant_txids_1, relevant_txids_2\n);\n\n// If any txids `relevant_txids` gets reorged out, you must call:\nchannel_manager.as_Listen().transaction_unconfirmed(unconfirmed_txid);\nchain_monitor.transaction_unconfirmed(unconfirmed_txid);\n\n/* CONFIRMED TRANSACTIONS */\n\n// Retrieve transactions and outputs to check the chain for confirmation.\n// These should've been given to you for monitoring via the `Filter` interface.\n\n// If any transactions or output spends appear on-chain, you must call:\nchannel_manager.as_Listen().transactions_confirmed(\n    header, height, confirmed_txs_list);\nchain_monitor.transactions_confirmed(header, height, confirmed_txs_list);\n\n/* CONNECTED OR DISCONNECTED BLOCKS */\n\n// Whenever there's a new chain tip or a block has been newly disconnected, you\n// must call:\nchannel_manager.update_best_block(new_best_header, new_best_height);\nchain_monitor.update_best_block(new_best_header, new_best_height);\n"))),Object(i.b)(o.a,{value:"java-blocks",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"// For each connected and disconnected block, and in chain-order, call these\n// methods.\n// If you're using BIP 157/158, then `txdata` below should always include any\n// transactions and/our outputs spends registered through the `Filter` interface,\n// Transactions and outputs are registered both on startup and as new relevant\n// transactions/outputs are created.\n\n// header is a []byte type, height is `int`, txdata is a \n// TwoTuple<Long, byte[]>[], where the 0th element is the transaction's position \n// in the block (with the coinbase transaction considered position 0) and the 1st \n// element is the transaction bytes\nchannel_manager.as_Listen().block_connected(header, txdata, height);\nchain_monitor.block_connected(header, txdata, height);\n\nchannel_manager.as_Listen().block_disconnected(header, height);\nchain_monitor.block_disconnected(header, height);\n")))),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Implementation notes:")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"If you're using the ",Object(i.b)("inlineCode",{parentName:"li"},"Listen")," interface: blocks must be connected and disconnected in chain order"),Object(i.b)("li",{parentName:"ul"},"If you're using the ",Object(i.b)("inlineCode",{parentName:"li"},"Confirm")," interface: // TODO")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Dependencies:")," ",Object(i.b)("inlineCode",{parentName:"p"},"ChannelManager"),", ",Object(i.b)("inlineCode",{parentName:"p"},"ChainMonitor")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"References:")," ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://docs.rs/lightning/*/lightning/chain/trait.Listen.html"}),"Rust ",Object(i.b)("inlineCode",{parentName:"a"},"Listen")," docs"),", ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://docs.rs/lightning/*/lightning/chain/trait.Confirm.html"}),"Rust ",Object(i.b)("inlineCode",{parentName:"a"},"Confirm")," docs")),Object(i.b)("h3",{id:"16-handle-ldk-events"},"16. Handle LDK Events"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"What it's used for:")," LDK generates events that must be handled by you, such as telling you when a payment has been successfully received or when a funding transaction is ready for broadcast."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Example:")," in Rust from the LDK sample node, of handling these events: ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/lightningdevkit/ldk-sample/blob/bc07db6ca4a3323d8718a27f85182b8157a20750/src/main.rs#L101-L240"}),"https://github.com/lightningdevkit/ldk-sample/blob/bc07db6ca4a3323d8718a27f85182b8157a20750/src/main.rs#L101-L240")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Example:")," of initializing an LDK event handler:"),Object(i.b)(l.a,{defaultValue:"rust",values:[{label:"Rust",value:"rust"},{label:"Java",value:"java"}],mdxType:"Tabs"},Object(i.b)(o.a,{value:"rust",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-rust"}),"// main.rs\n\nlet inbound_payments: PaymentInfoStorage = Arc::new(Mutex::new(HashMap::new()));\nlet outbound_payments: PaymentInfoStorage = Arc::new(Mutex::new(HashMap::new()));\nlet handle = tokio::runtime::Handle::current();\n\n// This handler will be used in step 18.\n// In this example, we provide a closure to handle events. But you're also free\n// to provide an implementation of the trait `EventHandler` instead.\nlet ldk_event_handler = move |event| {\n    handle.block_on(handle_ldk_events(\n        channel_manager.clone(),\n        bitcoind_client.clone(),\n        keys_manager.clone(),\n        inbound_payments.clone(),\n        outbound_payments.clone(),\n        network,\n        event,\n    ))\n};\n\nasync fn handle_ldk_events(..) {\n    match event {\n        Event::FundingGenerationReady { .. } => { .. }, // insert handling code\n        Event::PaymentReceived { .. } => { .. }, // insert handling code\n        Event::PaymentSent { .. } => { .. }, // insert handling code\n        Event::PaymentFailed { .. } => { .. }, // insert handling code\n        Event::PendingHTLCsForwardable { .. } => { .. }, // insert handling code\n        Event::SpendableOutputs { .. } => { .. } // insert handling code\n    }\n}\n"))),Object(i.b)(o.a,{value:"java",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"\npublic static void handleEvent(event: Event) {\n    if (event is Event.FundingGenerationReady) { .. } // insert handling code\n    if (event is Event.PaymentReceived) { .. } // insert handling code\n    if (event is Event.PaymentSent) { .. } // insert handling code\n    if (event is Event.PaymentFailed) { .. } // insert handling code\n    if (event is Event.PendingHTLCsForwardable) { .. } // insert handling code\n    if (event is Event.SpendableOutputs) { .. } // insert handling code\n}\n\n")))),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Implementation notes:")," "),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"It's important to read the documentation for individual event handling (linked in References below) to make sure event handling requirements are satisfied"),Object(i.b)("li",{parentName:"ul"},"Event handler initialization differs between Rust vs. other languages. Event handlers initialized in Rust are used in step 18, whereas event handlers initialized in Java/Swift are used in step 17."),Object(i.b)("li",{parentName:"ul"},"It is recommended to read through event handling in the LDK sample node (linked in the first example of this step above) to get an idea of what integrated LDK event handling looks like")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Dependencies:")," ",Object(i.b)("inlineCode",{parentName:"p"},"ChannelManager"),", ",Object(i.b)("inlineCode",{parentName:"p"},"ChainMonitor"),", ",Object(i.b)("inlineCode",{parentName:"p"},"KeysManager"),", ",Object(i.b)("inlineCode",{parentName:"p"},"BroadcasterInterface")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"References:")," ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://docs.rs/lightning/*/lightning/util/events/enum.Event.html"}),"Rust docs for ",Object(i.b)("inlineCode",{parentName:"a"},"Event"),"s"),", ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/lightningdevkit/ldk-garbagecollected/blob/main/src/main/java/org/ldk/structs/Event.java"}),"events to handle in Java")),Object(i.b)("h3",{id:"17-persist-channelmanager"},"17. Persist ",Object(i.b)("inlineCode",{parentName:"h3"},"ChannelManager")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"What it's used for:")," keeping ",Object(i.b)("inlineCode",{parentName:"p"},"ChannelManager"),"'s stored state up-to-date"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Example:")," initialize a ",Object(i.b)("inlineCode",{parentName:"p"},"ChannelManager")," persister"),Object(i.b)(l.a,{defaultValue:"rust",values:[{label:"Rust",value:"rust"},{label:"Java",value:"java"}],mdxType:"Tabs"},Object(i.b)(o.a,{value:"rust",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-rust"}),"// main.rs\n\n// This callback will be used in the step 18 for regular persistence.\nlet persist_channel_manager_callback = move |node: &ChannelManager| {\n    FilesystemPersister::persist_manager(ldk_data_dir.clone(), &*node)\n};\n"))),Object(i.b)(o.a,{value:"java",mdxType:"TabItem"},Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"// TODO: update this code from Kotlin to Java\nval channel_manager_persister = object: ChannelManagerPersister {\n  override fun handle_events(events: Array<Event?>?) {\n    events?.iterator()?.forEach {\n      if (it != null) handleEvent(it); // Use handleEvent function from step 16\n    }\n  }\n\n  override fun persist_manager(channel_manager_bytes: ByteArray?) {\n    if (channel_manager_bytes != null) {\n        // <insert code to persist the given ChannelManager bytes>\n    }\n  }\n}\n")))),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Implementation notes:")," if the ",Object(i.b)("inlineCode",{parentName:"p"},"ChannelManager")," is not persisted properly to disk, there is risk of channels force closing the next time LDK starts up. However, in this situation, no funds other than those used to pay force-closed channel fees are at risk of being lost."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Dependencies:")," ",Object(i.b)("inlineCode",{parentName:"p"},"ChannelManager")),Object(i.b)("h3",{id:"18-background-processing"},"18. Background Processing"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"What it's used for:")," running tasks periodically that aren't high-priority:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"ChannelManager"),"'s ",Object(i.b)("inlineCode",{parentName:"li"},"timer_chan_freshness_every_min()")," to broadcast fresh\nchannel updates if needed"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"PeerManager"),"'s ",Object(i.b)("inlineCode",{parentName:"li"},"timer_tick_occurred()")," to ping peers and disconnect from\nthose who haven't responded with pongs")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Example:")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"while (true) {\n    // <wait 60 seconds>\n    channel_manager.timer_chan_freshness_every_min();\n    // Note: NioPeerHandler handles calling timer_tick_occurred\n}\n")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Dependencies:")," ",Object(i.b)("inlineCode",{parentName:"p"},"ChannelManager")),Object(i.b)("h3",{id:"19-regularly-broadcast-node-announcement"},"19. Regularly Broadcast Node Announcement"),Object(i.b)("h2",{id:"using-ldk"},"Using LDK"),Object(i.b)("p",null,"This section assumes you've followed the steps of the ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#setup"}),"Setup")," and ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"#running-ldk"}),"Running LDK"),"."),Object(i.b)("h3",{id:"opening-a-channel"},"Opening a Channel"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Example:")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),'// <insert code to connect to peer via\n// NioPeerHandler.connect(byte[] their_node_id, SocketAddress remote)>\n\n// Create the initial channel of 10000 sats with a push_msat of 1000 and make\n// sure the result is successful. The `42` here can be any value, and it is not\n// used internally in LDK. It will be provided back to you in the\n// `Event.FundingGenerationReady` event as `user_channel_id`.\nbyte[] peer_node_pubkey = <peer node pubkey bytes>;\nResult_NoneAPIErrorZ create_channel_result = channel_manager.create_channel(\n    peer_node_pubkey, 10000, 1000, 42, null);\nassert create_channel_result instanceof Result_NoneAPIErrorZ.Result_NoneAPIErrorZ_OK;\n\n// Ensure we immediately send a `create_channel` message to the counterparty.\nnio_peer_handler.check_events();\n\n// After the peer responds with an `accept_channel` message, an\n// Event.FundingGenerationReady event will be generated.\n\n// In the background event handler thread (see "Handle LDK Events" section\n// above), the FundingGenerationReady event should be handled like this:\nif (e instanceof Event.FundingGenerationReady) {\n    byte[] funding_scriptpubkey = ((Event.FundingGenerationReady) e).output_script;\n    long output_value = ((Event.FundingGenerationReady) e).channel_value_satoshis;\n    // This is the same channel we just created, above:\n    assert ((Event.FundingGenerationReady) e).user_channel_id == 42;\n    // The output is always a P2WSH:\n    assert funding_scriptpubkey.length == 34 && funding_scriptpubkey[0] == 0 &&\n        funding_scriptpubkey[1] == 32;\n\n    // Generate the funding transaction for the channel based on the channel amount\n    NetworkParameters bitcoinj_net =\n        NetworkParameters.fromID(NetworkParameters.ID_MAINNET);\n    Transaction funding_tx = new Transaction(bitcoinj_net);\n    funding_tx.addInput(new TransactionInput(bitcoinj_net, funding, new byte[0]));\n    // Note that all inputs in the funding transaction MUST spend SegWit outputs\n    // (and have witnesses)\n    funding_tx.getInputs().get(0).setWitness(new TransactionWitness(2));\n    funding_tx.getInput(0).getWitness().setPush(0, new byte[]{0x1});\n    funding_tx.addOutput(Coin.SATOSHI.multiply(output_value),\n        new Script(funding_scriptpubkey));\n    short funding_output_index = (short) 0;\n\n    // Give the funding transaction back to the ChannelManager.\n    byte[] chan_id = ((Event.FundingGenerationReady) e).temporary_channel_id;\n    Result_NoneAPIErrorZ funding_res =\n        channel_manager.funding_transaction_generated(chan_id,\n            funding_tx.bitcoinSerialize(), funding_output_index);\n    // funding_transaction_generated should only generate an error if the\n    // transaction didn\'t meet the required format (or the counterparty already\n    // closed the channel on us):\n    assert funding_res instanceof Result_NoneAPIErrorZ.Result_NoneAPIErrorZ_OK;\n\n    // Ensure we immediately send a `funding_created` message to the counterparty.\n    nio_peer_handler.check_events();\n\n    // At this point LDK will exchange the remaining channel open messages with\n    // the counterparty and, when appropriate, broadcast the funding transaction\n    // provided.\n    // Once it confirms, the channel will be open and available for use (indicated\n    // by its presence in `channel_manager.list_usable_channels()`).\n}\n')),Object(i.b)("h3",{id:"closing-a-channel"},"Closing a Channel"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Example:")," cooperative close"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"// Assuming 1 open channel\nbyte[] channel_id = channel_manager.list_channels()[0].get_channel_id();\nResult_NoneAPIErrorZ close_result = channel_manager.close_channel(\n    channel_id);\nassert close_result instanceof Result_NoneAPIErrorZ.Result_NoneAPIErrorZ_OK;\n\n// Make sure the peer manager processes this new event.\nnio_peer_handler.check_events();\n")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Example:")," force/unilateral close"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"// Assuming 1 open channel\nbyte[] channel_id = channel_manager.list_channels()[0].get_channel_id();\nResult_NoneAPIErrorZ channel_manager.force_close_channel(channel_id);\n\n// Make sure the peer manager processes this new event.\nnio_peer_handler.check_events();\n")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Dependencies:")," ",Object(i.b)("inlineCode",{parentName:"p"},"ChannelManager"),", ",Object(i.b)("inlineCode",{parentName:"p"},"NioPeerHandler")),Object(i.b)("h3",{id:"list-channels"},"List Channels"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Example:")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"ChannelDetails[] channels = channel_manager.list_channels();\n")),Object(i.b)("h3",{id:"wip-sendingreceiving-payments"},"WIP: Sending/Receiving Payments"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"NOTE: CURRENTLY UNSUPPORTED IN JAVA")),Object(i.b)("p",null,"Currently unsatisfied dependencies:"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"a way of constructing ",Object(i.b)("inlineCode",{parentName:"li"},"NodeFeatures")," and ",Object(i.b)("inlineCode",{parentName:"li"},"ChannelFeatures")," LDK structs (which should be exposed soon)"),Object(i.b)("li",{parentName:"ol"},"a way to parse invoices (we need to generate bindings for the ",Object(i.b)("inlineCode",{parentName:"li"},"rust-invoices")," crate)")),Object(i.b)("h3",{id:"connect-to-peers"},"Connect to Peers"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Example:")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"byte[] peer_pubkey = // insert peer's pubkey bytes\nint peer_port = 9735; // replace this with the peer's port number\nString peer_host = \"192.168.1.2\"; // replace this with the peer's host\nSocketAddress peer_socket_addr = new InetSocketAddress(peer_host, peer_port);\nnio_peer_handler.connect(peer_pubkey, peer_socket_address);\n")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Dependencies:")," ",Object(i.b)("inlineCode",{parentName:"p"},"PeerManager"),", peer's pubkey/host/port"),Object(i.b)("h3",{id:"list-peers"},"List Peers"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Example:")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"byte[][] peer_node_ids = peer_manager.get_peer_node_ids();\n")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Dependencies:")," ",Object(i.b)("inlineCode",{parentName:"p"},"PeerManager")))}p.isMDXComponent=!0},85:function(e,n,t){"use strict";function a(e){var n,t,r="";if("string"==typeof e||"number"==typeof e)r+=e;else if("object"==typeof e)if(Array.isArray(e))for(n=0;n<e.length;n++)e[n]&&(t=a(e[n]))&&(r&&(r+=" "),r+=t);else for(n in e)e[n]&&(r&&(r+=" "),r+=n);return r}n.a=function(){for(var e,n,t=0,r="";t<arguments.length;)(e=arguments[t++])&&(n=a(e))&&(r&&(r+=" "),r+=n);return r}},87:function(e,n,t){"use strict";t.d(n,"a",(function(){return d})),t.d(n,"b",(function(){return h}));var a=t(0),r=t.n(a);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var c=r.a.createContext({}),b=function(e){var n=r.a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},d=function(e){var n=b(e.components);return r.a.createElement(c.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.a.createElement(r.a.Fragment,{},n)}},u=r.a.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=b(t),u=a,h=d["".concat(l,".").concat(u)]||d[u]||p[u]||i;return t?r.a.createElement(h,o(o({ref:n},c),{},{components:t})):r.a.createElement(h,o({ref:n},c))}));function h(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,l=new Array(i);l[0]=u;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o.mdxType="string"==typeof e?e:a,l[1]=o;for(var c=2;c<i;c++)l[c]=t[c];return r.a.createElement.apply(null,l)}return r.a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},93:function(e,n,t){"use strict";var a=t(0),r=t(94);n.a=function(){const e=Object(a.useContext)(r.a);if(null==e)throw new Error("`useUserPreferencesContext` is used outside of `Layout` Component.");return e}},94:function(e,n,t){"use strict";var a=t(0);const r=Object(a.createContext)(void 0);n.a=r},99:function(e,n,t){"use strict";var a=t(0),r=t.n(a),i=t(93),l=t(85),o=t(53),s=t.n(o);const c=37,b=39;n.a=function(e){const{lazy:n,block:t,defaultValue:o,values:d,groupId:p,className:u}=e,{tabGroupChoices:h,setTabGroupChoices:m}=Object(i.a)(),[g,j]=Object(a.useState)(o),O=a.Children.toArray(e.children);if(null!=p){const e=h[p];null!=e&&e!==g&&d.some((n=>n.value===e))&&j(e)}const _=e=>{j(e),null!=p&&m(p,e)},f=[];return r.a.createElement("div",null,r.a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:Object(l.a)("tabs",{"tabs--block":t},u)},d.map((({value:e,label:n})=>r.a.createElement("li",{role:"tab",tabIndex:0,"aria-selected":g===e,className:Object(l.a)("tabs__item",s.a.tabItem,{"tabs__item--active":g===e}),key:e,ref:e=>f.push(e),onKeyDown:e=>{((e,n,t)=>{switch(t.keyCode){case b:((e,n)=>{const t=e.indexOf(n)+1;e[t]?e[t].focus():e[0].focus()})(e,n);break;case c:((e,n)=>{const t=e.indexOf(n)-1;e[t]?e[t].focus():e[e.length-1].focus()})(e,n)}})(f,e.target,e)},onFocus:()=>_(e),onClick:()=>{_(e)}},n)))),n?Object(a.cloneElement)(O.filter((e=>e.props.value===g))[0],{className:"margin-vert--md"}):r.a.createElement("div",{className:"margin-vert--md"},O.map(((e,n)=>Object(a.cloneElement)(e,{key:n,hidden:e.props.value!==g})))))}}}]);